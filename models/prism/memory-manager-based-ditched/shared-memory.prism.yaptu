// variable is v_ because making the name variable in
// yaptu makes this document look even more ugly

ctmc

const int v_min = 0;
const int v_max = $VALUE_COUNT-1$;

// rates
const double wr       = 2; // write rate
const double rr       = 2; // read rate
const double pr       = 2; // push rate
const double rer      = 2; // restart rate
const double ir       = 2; // invalidation rate
const double pir      = 2; // push inform rate
const double reactive = 1; // always 1


// rules of usage:
//
//  * never query for v_valid0, or anything else memory manager control flow related
//
//  * always v_request_write0 before v_write0
//  * always v_write0 after v_request_write0
//  * analogue holds for read

module thread0
  v_0 : [v_min..v_max];

  // example writing
  [v_request_write0] true -> wr:true;
++ for i in xrange(0,VALUE_COUNT):
  [v_write0] true -> reactive:(v_0'=$i$);
--

  // example reading
  [v_request_read0] true -> rr:true;
++ for j in xrange(1,THREAD_COUNT):
  [v_read0$j$] true -> reactive:(v_0'=v_$j$);
--
endmodule


++ for i in xrange(1,THREAD_COUNT):
module thread$i$ = thread0 [
  v_0=v_$i$, $", ".join([ "v_%d=v_%d" % (j+1, j+(j>=i))for j in xrange(0,THREAD_COUNT-1)])$,
  v_request_write0=v_request_write$i$, v_write0=v_write$i$, v_request_read0=v_request_read$i$,
  $", ".join(["v_read0%d=v_read%d%d" %(j+1, i, j+(j>=i)) for j in xrange(0,THREAD_COUNT-1)])$
]
endmodule
--


// BEGIN Memory Managaer

++ if DEBUG:
label "error" = v_ownerError;
--

formula v_noInforms     = ($" & ".join([" & ".join([ "v_inform%d%d=false" % (i, j) for j in xrange(0,THREAD_COUNT) if i != j])  for i in xrange(0,THREAD_COUNT)])$);
formula v_noInvalidates = ($" & ".join(["v_invalidate%d=false" %i for i in xrange(0,THREAD_COUNT)])$);
formula v_readReady     = (v_noInforms & v_noInvalidates);
formula v_writeReady    = (v_readReady);

module v_validity
++ for i in xrange(0,THREAD_COUNT):
++ if i==0:
  v_valid$i$: bool init true;
--
++ if i!=0:
  v_valid$i$: bool init false;
--
--

++ for i in xrange(0,THREAD_COUNT):
  [v_invalidate$i$] true -> reactive:(v_valid$i$'=false);
--

++ for i in xrange(0,THREAD_COUNT):
++ for j in xrange(0,THREAD_COUNT):
++ if (i!=j):
  [v_read$i$$j$] true -> reactive:(v_valid$i$'=true);
--
--
--

++ for i in xrange(0,THREAD_COUNT):
  [v_write$i$] true -> reactive:(v_valid$i$'=true);
--
endmodule

module v_ownership
  v_currentOwner : [-1..$THREAD_COUNT$] init  0;
  v_nextOwner    : [-1..$THREAD_COUNT$] init -1;    //makes sure no writes are triggered without a request for writing
++ if DEBUG:
  v_ownerError   : bool    init false; // is false, if the order of requests/writes is wrong
--

++ for i in xrange(0,THREAD_COUNT):
  [v_request_write$i$] v_nextOwner =-1 -> reactive:(v_nextOwner' =$i$);
++ if DEBUG:
  [v_request_write$i$] v_nextOwner!=-1 ->          (v_ownerError'=true);
--
--

++ for i in xrange(0,THREAD_COUNT):
  [v_write$i$] v_nextOwner= $i$ -> reactive:(v_currentOwner'=$i$) & (v_nextOwner'=-1);
++ if DEBUG:
  [v_write$i$] v_nextOwner=-1 ->          (v_ownerError'=true);
++ for j in xrange(0,THREAD_COUNT):
++ if i!=j:
  [v_write$i$] v_nextOwner= $j$ ->          (v_ownerError'=true);
--
--
--
--
endmodule

// locations for mm control flow
const int idling       = 0;
const int invalidating = 1;
const int writing      = 2;
const int informing    = 3;
const int reading      = 4;

module v_mm_control_flow
  v_l : [0..4] init idling;

++ for i in xrange(0,THREAD_COUNT):
  [v_request_write$i$] (v_l=idling) & v_writeReady -> reactive:(v_l'=invalidating);
--

++ for i in xrange(0,THREAD_COUNT):
  [v_write$i$] (v_l=invalidating) & v_writeReady -> reactive:(v_l'=writing);
--

++ for i in xrange(0,THREAD_COUNT):
  [v_push_inform$i$] (v_l=writing) -> reactive:(v_l'=informing);
--

++ for i in xrange(0,THREAD_COUNT):
  [v_request_read$i$] (v_l=idling) & v_readReady -> reactive:(v_l'=reading);
--

  [v_restart] (v_l=reading) & v_readReady  -> rer:(v_l'=idling);
  [v_restart] (v_l=informing)  & v_writeReady -> rer:(v_l'=idling);
endmodule

module v_mm_activity
++ for i in xrange(0,THREAD_COUNT):
  v_invalidate$i$ : bool init false;
--

++ for i in xrange(0,THREAD_COUNT):
++ for j in xrange(0,THREAD_COUNT):
++ if i!=j:
  v_inform$i$$j$ : bool init false;
--
--
--

  // invalidating
++ for i in xrange(0,THREAD_COUNT):
  [v_request_write$i$] true -> reactive:$" & ".join(["(v_invalidate%d'=true)" %j for j in xrange(0,THREAD_COUNT) if i!=j])$;
--

++ for i in xrange(0,THREAD_COUNT):
  [v_invalidate$i$] (v_invalidate$i$=true) -> ir:(v_invalidate$i$'=false);
--

  // pushes triggered by writing
++ for i in xrange(0,THREAD_COUNT):
  [v_push_inform$i$] (v_currentOwner=$i$) -> pir:$" & ".join(["(v_inform%d%d'=true)" % (k,j) for k in [i] for j in xrange(0,THREAD_COUNT) if i!=j])$;
--

  // pushes triggered by reading
++ for i in xrange(0,THREAD_COUNT):
++ for j in xrange(0,THREAD_COUNT):
++ if i!=j:
  [v_request_read$i$] (v_currentOwner=$j$) -> reactive:(v_inform$j$$i$'=true);
--
--
--

  // pushes triggered by either reads or writes
++ for i in xrange(0,THREAD_COUNT):
++ for j in xrange(0,THREAD_COUNT):
++ if i!=j:
  [v_read$i$$j$] (v_inform$j$$i$=true) -> pr:(v_inform$j$$i$'=false);
--
--
--
endmodule

// END Memory Manager

// costs model - states
const double idlingCosts       = 0;
const double invalidatingCosts = 1;
const double writingCosts      = 2;
const double informingCosts    = 3;
const double readingCosts      = 4;

rewards "v_location_costs"
  (v_l=idling)       : idlingCosts;
  (v_l=invalidating) : invalidatingCosts;
  (v_l=writing)      : writingCosts;
  (v_l=informing)    : informingCosts;
  (v_l=reading)      : readingCosts;
endrewards

// costs model - transitions
const double invalidateCosts  = 0.25;
const double writeCosts       = 2.0;
const double readCosts        = 1.0;

const double pushInformCosts   = 0.5;
const double requestReadCosts  = 0.5;
const double requestWriteCosts = 0.5;

rewards "transition_costs"
++ for i in xrange(0,THREAD_COUNT):
  [v_request_write$i$] true : requestWriteCosts;
--

++ for i in xrange(0,THREAD_COUNT):
  [v_push_inform$i$] true : pushInformCosts;
--

++ for i in xrange(0,THREAD_COUNT):
  [v_request_read$i$] true : requestReadCosts;
--

++ for i in xrange(0,THREAD_COUNT):
  [v_invalidate$i$] true : invalidateCosts;
--

++ for i in xrange(0,THREAD_COUNT):
  [v_write$i$] true : writeCosts;
--

++ for i in xrange(0,THREAD_COUNT):
++ for j in xrange(0,THREAD_COUNT):
++ if i!=j:
  [v_read$i$$j$] true : readCosts;
--
--
--

  // [v_restart] true : 0; // (hidden)
endrewards

// composition (not yet useable by simulator)
// system
//   (thread0 || thread1 || thread2 || v_validity || v_ownership || v_mm_control_flow / {v_restart} || v_mm_activity)
// endsystem
