ctmc

// barrier local variable limits
const int bar_min = -1;
const int bar_max =  $THREAD_COUNT$;

// memory menager parameters
const double wr       = 2;
const double rr       = 2;
const double pr       = 2;
const double rer      = 2;
const double ir       = 2;
const double pir      = 2;
const double reactive = 1;

// barrier rates
const double baser    = 1;
const double workr    = baser / 1000.0;

// thread0 locations
const int l_error          = -1;
const int l_work           =  0;
const int l_addFetchRead1  =  1;
const int l_addFetchRead2  =  2;
const int l_addFetchWrite1 =  3;
const int l_addFetchWrite2 =  4;
const int l_checkComplete1 =  5;
const int l_checkComplete2 =  6;
const int l_complete       =  7;


module thread0
  l_0 : [-1..7] init l_work;
  bar_0 : [bar_min..bar_max] init bar_max;

  // accept data pushed from i to 0, except when we are already waiting on the bar_push i 0 label
++ for i in xrange(1,THREAD_COUNT):
  [bar_push$i$0] (l_0!=l_checkComplete2) & (l_0!=l_addFetchRead2) -> reactive:(bar_0'=bar_$i$);
--


  // start of protocol
  [] l_0=l_work -> workr : (l_0'=l_addFetchRead1);

  // read barrier
  []               (l_0=l_addFetchRead1) & ( bar_valid0) ->          (l_0'=l_addFetchWrite1);
  [bar_push_read0] (l_0=l_addFetchRead1) & (!bar_valid0) -> rr:      (l_0'=l_addFetchRead2);
++ for i in xrange(1,THREAD_COUNT):
  [bar_push$i$0]     (l_0=l_addFetchRead2)                 -> reactive:(l_0'=l_addFetchWrite1) & (bar_0'=bar_$i$);
--

  // write barrier
  [bar_push_write0] (l_0=l_addFetchWrite1)              -> wr:      (l_0'=l_addFetchWrite2);
  [bar_write0]      (l_0=l_addFetchWrite2) & (bar_0> 0) -> reactive:(l_0'=l_checkComplete1) & (bar_0'=max(bar_0-1,0));
  [bar_write0]      (l_0=l_addFetchWrite2) & (bar_0<=0) ->          (l_0'=l_error);

  // check if complete
  []               (l_0=l_checkComplete1) & ( bar_valid0) & (bar_0>0) ->          (l_0'=l_checkComplete1);
  []               (l_0=l_checkComplete1) & ( bar_valid0) & (bar_0=0) ->          (l_0'=l_complete);
  []               (l_0=l_checkComplete1) & ( bar_valid0) & (bar_0<0) ->          (l_0'=l_error);
  [bar_push_read0] (l_0=l_checkComplete1) & (!bar_valid0)             -> rr:      (l_0'=l_checkComplete2);
++ for i in xrange(1,THREAD_COUNT):
  [bar_push$i$0]     (l_0=l_checkComplete2)                 & (bar_$i$>0) -> reactive:(l_0'=l_checkComplete1) & (bar_0'=bar_$i$);
--
++ for i in xrange(1,THREAD_COUNT):
  [bar_push$i$0]     (l_0=l_checkComplete2)                 & (bar_$i$=0) -> reactive:(l_0'=l_complete);
  [bar_push$i$0]     (l_0=l_checkComplete2)                 & (bar_$i$<0) -> reactive:(l_0'=l_error);
--
endmodule

++ for i in xrange(1,THREAD_COUNT):
module thread$i$ = thread0 [
  l_0=l_$i$,
  bar_0=bar_$i$,
  bar_valid0=bar_valid$i$,
++ for j in xrange(0,THREAD_COUNT-1):
  bar_$j+1$=bar_$j+(j>=i)$,
--

  // messages:
  bar_push_write0=bar_push_write$i$, bar_write0=bar_write$i$,
++ for j in xrange(0,THREAD_COUNT-1):
  bar_push$j+1$0=bar_push$j+(j>=i)$$i$,
--
  bar_push_read0=bar_push_read$i$
]
endmodule

--

// BEGIN Memory Managaer

++ for j in xrange(0,THREAD_COUNT):
formula bar_inform$j$       = ($' & '.join(['bar_inform%d%d=false' %(k,i) for k in [j] for i in xrange(0,THREAD_COUNT) if i!=j])$);
--
formula bar_noInforms     = ($' & '.join(['bar_inform%d' %i for i in xrange(0,THREAD_COUNT)])$);
formula bar_noInvalidates = ($' & '.join(['bar_invalidate%d=false' %i for i in xrange(0,THREAD_COUNT)])$);
formula bar_readReady     = (bar_noInforms & bar_noInvalidates);
formula bar_writeReady    = (bar_readReady);

// global variables valid i encapsulated in a separate module
module bar_validity
++ for i in xrange(0,THREAD_COUNT):
++ if i==0:
  bar_valid$i$: bool init true;
--
++ if i!=0:
  bar_valid$i$: bool init false;
--
--

++ for i in xrange(0,THREAD_COUNT):
  [bar_set_invalid$i$] true -> reactive:(bar_valid$i$'=false);
--

++ for i in xrange(0,THREAD_COUNT):
++ for j in xrange(0,THREAD_COUNT):
++ if (i!=j):
  [bar_push$i$$j$] true -> reactive:(bar_valid$j$'=true);
--
--
--
endmodule

// global variables for ownership encapsulated in a separate module
module bar_ownership
  bar_currentOwner : [-1..$THREAD_COUNT$] init 0;
  bar_nextOwner : [-1..$THREAD_COUNT$] init -1;

++ for i in xrange(0,THREAD_COUNT):
  [bar_push_write$i$] true -> reactive:(bar_nextOwner'=$i$);
--

++ for i in xrange(0,THREAD_COUNT):
  [bar_write$i$] bar_nextOwner=$i$ -> wr:(bar_currentOwner'=$i$);
--
endmodule

// locations for mm control flow
const int idle       = 0;
const int invalidate = 1;
const int writing    = 2;
const int inform     = 3;
const int reading    = 4;

module bar_mm_control_flow
  bar_loc : [0..4] init idle;

++ for i in xrange(0,THREAD_COUNT):
  [bar_push_write$i$] (bar_loc=idle) & bar_writeReady -> reactive:(bar_loc'=invalidate);
--

++ for i in xrange(0,THREAD_COUNT):
  [bar_write$i$] (bar_loc=invalidate) & bar_writeReady -> reactive:(bar_loc'=writing);
--

++ for i in xrange(0,THREAD_COUNT):
  [bar_push_inform$i$] (bar_loc=writing) -> reactive:(bar_loc'=inform);
--

++ for i in xrange(0,THREAD_COUNT):
  [bar_push_read$i$] (bar_loc=idle) & bar_readReady -> reactive:(bar_loc'=reading);
--

  [bar_restart] (bar_loc=reading) & bar_readReady  -> rer:(bar_loc'=idle);
  [bar_restart] (bar_loc=inform)  & bar_writeReady -> rer:(bar_loc'=idle);
endmodule

// mm actions
module bar_mm_activity
++ for i in xrange(0,THREAD_COUNT):
  bar_invalidate$i$ : bool init false;
--

++ for i in xrange(0,THREAD_COUNT):
++ for j in xrange(0,THREAD_COUNT):
++ if i!=j:
  bar_inform$i$$j$ : bool init false;
--
--
--

  // invalidating
++ for i in xrange(0,THREAD_COUNT):
  [bar_push_write$i$] true -> reactive:$' & '.join(['(bar_invalidate%d\'=true)' %j for j in xrange(0,THREAD_COUNT) if i!=j])$;
--

++ for i in xrange(0,THREAD_COUNT):
  [bar_set_invalid$i$] (bar_invalidate$i$=true) -> ir:(bar_invalidate$i$'=false);
--

  // pushes triggered by writing
++ for i in xrange(0,THREAD_COUNT):
  [bar_push_inform$i$] (bar_currentOwner=$i$) -> pir:$' & '.join(['(bar_inform%d%d\'=true)' % (k,j) for k in [i] for j in xrange(0,THREAD_COUNT) if i!=j])$;
--

  // pushes triggered by reading
++ for i in xrange(0,THREAD_COUNT):
++ for j in xrange(0,THREAD_COUNT):
++ if i!=j:
  [bar_push_read$i$] (bar_currentOwner=$j$) -> reactive:(bar_inform$j$$i$'=true);
--
--
--

  // pushes (triggered by either reads or writes)
++ for i in xrange(0,THREAD_COUNT):
++ for j in xrange(0,THREAD_COUNT):
++ if i!=j:
  [bar_push$i$$j$] (bar_inform$i$$j$=true) -> pr:(bar_inform$i$$j$'=false);
--
--
--
endmodule

// END Memory Manager

// costs model - states
const double idleCosts       = 0;
const double invalidateCosts = 1;
const double writingCosts    = 2;
const double informCosts     = 3;
const double readingCosts    = 4;

rewards "bar_location_costs"
  (bar_loc=idle)       : idleCosts;
  (bar_loc=invalidate) : invalidateCosts;
  (bar_loc=writing)    : writingCosts;
  (bar_loc=inform)     : informCosts;
  (bar_loc=reading)    : readingCosts;
endrewards

// costs model - transitions
const double invCosts         = 0.25;
const double writeCosts       = 2.0;
const double readCosts        = 1.0;

const double pushMessageCosts = 0.5;
const double pushInvCosts     = pushMessageCosts;
const double pushInformCosts  = pushMessageCosts;
const double pushReadCosts    = pushMessageCosts;

rewards "transition_costs"
  // push_message costs
++ for i in xrange(0,THREAD_COUNT):
  [bar_push_write$i$] true : pushInvCosts;
--

++ for i in xrange(0,THREAD_COUNT):
  [bar_push_inform$i$] true : pushInformCosts;
--

++ for i in xrange(0,THREAD_COUNT):
  [bar_push_read$i$] true : pushReadCosts;
--

  // invalidation costs
++ for i in xrange(0,THREAD_COUNT):
  [bar_set_invalid$i$] true : invCosts;
--

  // write costs
++ for i in xrange(0,THREAD_COUNT):
  [bar_write$i$] true : writeCosts;
--

  // read costs
++ for i in xrange(0,THREAD_COUNT):
++ for j in xrange(0,THREAD_COUNT):
++ if i!=j:
  [bar_push$i$$j$] true : readCosts;
--
--
--

  // [bar_restart] true : 0; // (hidden)
endrewards

// composition (not yet useable by simulator)
// system
//   (thread0 || thread1 || thread2 || bar_validity || bar_ownership || bar_mm_control_flow / {bar_restart} || bar_mm_activity)
// endsystem
