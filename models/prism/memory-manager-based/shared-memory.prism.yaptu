ctmc

const int v_min = 0;
const int v_max = $VALUE_COUNT-1$;

// rates
const double wr       = 2; // write rate
const double rr       = 2; // read rate
const double pr       = 2; // push rate
const double rer      = 2; // restart rate
const double ir       = 2; // invalidate rate
const double pir      = 2; // push inform rate
const double reactive = 1; // always 1


module thread0
  v_0 : [v_min..v_max];

  // example writing:
  [v_push_write0] true -> wr:true;
++ for i in xrange(0,VALUE_COUNT):
  [v_write0] true -> reactive:(v_0'=$i$);
--

  // example reading:
  [v_push_read0] true -> rr:true;
++ for j in xrange(1,THREAD_COUNT):
  [v_push$j$0] true -> reactive:(v_0'=v_$j$);
--
endmodule


++ for i in xrange(1,THREAD_COUNT):
module thread$i$ = thread0 [
  v_0=v_$i$, $", ".join([ "v_%d=v_%d" % (j+1, j+(j>=i))for j in xrange(0,THREAD_COUNT-1)])$,
  v_valid0=v_valid$i$,
  v_push_write0=v_push_write$i$, v_write0=v_write$i$, v_push_read0=v_push_read$i$,
  $", ".join(["v_push%d0=v_push%d%d" %(j+1, j+(j>=i), i) for j in xrange(0,THREAD_COUNT-1)])$
]
endmodule
--


// BEGIN Memory Managaer

formula v_noInforms     = ($" & ".join([" & ".join([ "v_inform%d%d=false" % (i, j) for j in xrange(0,THREAD_COUNT) if i != j])  for i in xrange(0,THREAD_COUNT)])$);
formula v_noInvalidates = ($" & ".join(["v_invalidate%d=false" %i for i in xrange(0,THREAD_COUNT)])$);
formula v_readReady     = (v_noInforms & v_noInvalidates);
formula v_writeReady    = (v_readReady);

module v_validity
++ for i in xrange(0,THREAD_COUNT):
++ if i==0:
  v_valid$i$: bool init true;
--
++ if i!=0:
  v_valid$i$: bool init false;
--
--

++ for i in xrange(0,THREAD_COUNT):
  [v_set_invalid$i$] true -> reactive:(v_valid$i$'=false);
--

++ for i in xrange(0,THREAD_COUNT):
++ for j in xrange(0,THREAD_COUNT):
++ if (i!=j):
  [v_push$i$$j$] true -> reactive:(v_valid$j$'=true);
--
--
--
endmodule

module v_ownership
  v_currentOwner : [-1..$THREAD_COUNT$] init 0;
  v_nextOwner : [-1..$THREAD_COUNT$] init -1;

++ for i in xrange(0,THREAD_COUNT):
  [v_push_write$i$] true -> reactive:(v_nextOwner'=$i$);
--

++ for i in xrange(0,THREAD_COUNT):
  [v_write$i$] v_nextOwner=$i$ -> wr:(v_currentOwner'=$i$);
--
endmodule

// locations for mm control flow
const int idle       = 0;
const int invalidate = 1;
const int writing    = 2;
const int inform     = 3;
const int reading    = 4;

module v_mm_control_flow
  v_l : [0..4] init idle;

++ for i in xrange(0,THREAD_COUNT):
  [v_push_write$i$] (v_l=idle) & v_writeReady -> reactive:(v_l'=invalidate);
--

++ for i in xrange(0,THREAD_COUNT):
  [v_write$i$] (v_l=invalidate) & v_writeReady -> reactive:(v_l'=writing);
--

++ for i in xrange(0,THREAD_COUNT):
  [v_push_inform$i$] (v_l=writing) -> reactive:(v_l'=inform);
--

++ for i in xrange(0,THREAD_COUNT):
  [v_push_read$i$] (v_l=idle) & v_readReady -> reactive:(v_l'=reading);
--

  [v_restart] (v_l=reading) & v_readReady  -> rer:(v_l'=idle);
  [v_restart] (v_l=inform)  & v_writeReady -> rer:(v_l'=idle);
endmodule

module v_mm_activity
++ for i in xrange(0,THREAD_COUNT):
  v_invalidate$i$ : bool init false;
--

++ for i in xrange(0,THREAD_COUNT):
++ for j in xrange(0,THREAD_COUNT):
++ if i!=j:
  v_inform$i$$j$ : bool init false;
--
--
--

  // invalidating
++ for i in xrange(0,THREAD_COUNT):
  [v_push_write$i$] true -> reactive:$" & ".join(["(v_invalidate%d'=true)" %j for j in xrange(0,THREAD_COUNT) if i!=j])$;
--

++ for i in xrange(0,THREAD_COUNT):
  [v_set_invalid$i$] (v_invalidate$i$=true) -> ir:(v_invalidate$i$'=false);
--

  // pushes triggered by writing
++ for i in xrange(0,THREAD_COUNT):
  [v_push_inform$i$] (v_currentOwner=$i$) -> pir:$" & ".join(["(v_inform%d%d'=true)" % (k,j) for k in [i] for j in xrange(0,THREAD_COUNT) if i!=j])$;
--

  // pushes triggered by reading
++ for i in xrange(0,THREAD_COUNT):
++ for j in xrange(0,THREAD_COUNT):
++ if i!=j:
  [v_push_read$i$] (v_currentOwner=$j$) -> reactive:(v_inform$j$$i$'=true);
--
--
--

  // pushes (triggered by either reads or writes)
++ for i in xrange(0,THREAD_COUNT):
++ for j in xrange(0,THREAD_COUNT):
++ if i!=j:
  [v_push$i$$j$] (v_inform$i$$j$=true) -> pr:(v_inform$i$$j$'=false);
--
--
--
endmodule

// END Memory Manager

// costs model - states
const double idleCosts       = 0;
const double invalidateCosts = 1;
const double writingCosts    = 2;
const double informCosts     = 3;
const double readingCosts    = 4;

rewards "v_location_costs"
  (v_l=idle)       : idleCosts;
  (v_l=invalidate) : invalidateCosts;
  (v_l=writing)    : writingCosts;
  (v_l=inform)     : informCosts;
  (v_l=reading)    : readingCosts;
endrewards

// costs model - transitions
const double invCosts         = 0.25;
const double writeCosts       = 2.0;
const double readCosts        = 1.0;

const double pushMessageCosts = 0.5;
const double pushInvCosts     = pushMessageCosts;
const double pushInformCosts  = pushMessageCosts;
const double pushReadCosts    = pushMessageCosts;

rewards "transition_costs"
++ for i in xrange(0,THREAD_COUNT):
  [v_push_write$i$] true : pushInvCosts;
--

++ for i in xrange(0,THREAD_COUNT):
  [v_push_inform$i$] true : pushInformCosts;
--

++ for i in xrange(0,THREAD_COUNT):
  [v_push_read$i$] true : pushReadCosts;
--

++ for i in xrange(0,THREAD_COUNT):
  [v_set_invalid$i$] true : invCosts;
--

++ for i in xrange(0,THREAD_COUNT):
  [v_write$i$] true : writeCosts;
--

++ for i in xrange(0,THREAD_COUNT):
++ for j in xrange(0,THREAD_COUNT):
++ if i!=j:
  [v_push$i$$j$] true : readCosts;
--
--
--

  // [v_restart] true : 0; // (hidden)
endrewards

// composition (not yet useable by simulator)
// system
//   (thread0 || thread1 || thread2 || v_validity || v_ownership || v_mm_control_flow / {v_restart} || v_mm_activity)
// endsystem
