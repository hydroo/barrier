--- 13-04-27 ---

 □ next todo: model an atomic increment spin barrier
   -> compare to ours

 * implemented another simple model minimization (copy=0 as early as possible). semantically and quant. equivalent
 * new variant: remember whom you have seen: in models/prism/ctmc/with-cache + git/models/spin/remember-others

   n: 3, work: 0, read: 50, write: 100

          |dont remember others         |remember others
          |normal         one-loop      |normal         one-loop
   -------+-----------------------------+-------------------------
   states |259102         7789          |322957         10195
   trans  |777306         23199         |968871         30384
   matrix |336231         31085         |335075         33451

   clraR 1|300    copied  326           |262            296
   clraR 2|476    c       533           |441            496
   clraR 3|407    c       177           |328            177
   SS m   |0.076  c       0.291         |0.09           0.291
   SS s   |0.617  c       0.100         |0.55           0.100
   SS i   |0.307  c       0.609         |0.36           0.609

 □ clraR3 sollte etwa 2 - 1 sein. Formel falsch?


 □ one loop's wrongness might get better with more processes
   in order to make it better for small numbers of processes give the self loop
   the shape of the second loop (red tick read repeat) and omit all the logic

 □ add energy reward

--- 13-04-26 ---

n: 3, work: 0, read: 50, write: 100

       |normal         one-loop
-------+-----------------------
states |364701         10795
trans  |1094103        31647
matrix |438694         39024

clraR 1|304            326
clraR 2|487            533
clraR 3|414            177
SS m   |0.076          0.291
SS s   |0.617          0.100
SS i   |0.307          0.609

deutet auf fehler im normal-no-work, oder?


--- 13-04-15 ---

 paper meeting (baier,klueppel,tews,mc guire,mvoelp):

                 | las vegas  | monte carlo
 ----------------+------------+-----------------
 bounded runtime | variant y? | current barrier
 ----------------+------------+-----------------
 prob runtime    | pwcs       | variant x?
 ----------------+------------+-----------------
 energy effic    | ?          | ?


 possible topics
  * barrier construction (story?)
   * variants
  * model
  * analysis
   * garantierter fortschritt

  * energie
   * mwait/backoff
   * ???
   * ???
 
 schedule
  * 4-15 today
  ???
  * 4-22 small meeting
   * discuss variants
  ???
  * 4-29 bigger meeting
  ???
  * 5-13 to 5-30 writing

  * konferenz aussuchen

--- 13-04-13 ---

 grosser beleg meeting (baier, klueppel, tews):

 energie effizienz!
   * Beleg soll (irgendwie) in HAEC rein
   * RAPL
     ✗ leider, keine Moeglichkeit nachzuahmen (ausser memory/dram: paper "RAPL: Memory ...")
       □  aber es gibt projekte wie zB mummi die Modelle erstellen (paper "Power-Aware Predictive ...")
   * messen am board mit ~100ns moeglich

 algorithmus:
   * verteilte variante machen
     -> neues modell
   * andere varianten ausprobieren
   * parametrisieren
     * was parametrisieren?
     * Auswahl von energieeffizient bis performant

 modell:
   * wofuer?
     * gute parameter fuer den algorithmus aus dem modell ableiten
     * skalierung/performance mit mehr prozessen als messbar vorhersehen
     * argumentieren, dass der algorithmus gut ist
   * (system-/arbeits-)last nur sehr einfach modellieren. keine arbeit in gute last-modellierung stecken
 
 sonstiges:
  * die one-loop variante nicht untersuchen

--- before 13-04-01 ---

 □ make it work in a distributed setting
 
 □ go beyond 32 threads (i.e. use an array rather than one barrier variable)

 ✓ not only add yourself to the barrier, but everyone you have seen so far, too

 □ implement/model simple atomic increment barrier and compare against our protocol

 □ it might work to just remove copy and work directly on the shared vars.
   One more shared read, but a variable less (the model would be happy, perhaps)

 □ implement model minimizations
  -> □ scale model for more threads
  e.g.:
   * remove second loop
   * put cacheline state into a central object. e.g. in the case of modified, it is not needed to save the distinct state of the n-1 other threads because is implied.
   * symmetry
   * partial order

 □ maybe model that during the work period the cacheline state might change

 actual implementation:
   □ try mwait, pause for the loops
   □ use back-off strategies
   □ address nthreads > maxthreads case
