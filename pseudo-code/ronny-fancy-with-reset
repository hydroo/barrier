variables:

  shared:
    barrier1[numThreads] (each process owns its own array element)
    barrier2[numThreads]
    barrier3[numThreads]
  local:
    me := $2^{threadIndex}$
    full := $\sum_{i=0}^{numThreads-1}2^i$
  init:
    barrier1[*] := full
    barrier2[*] := full
    barrier3[*] := 0                                                     // not resetted

code per thread/process:

  if barrier3[threadIndex] == 0 {                                        // is barrier3 finished(=not resetted)?
    barrier(barrier1, barrier3)
  } else if barrier1[threadIndex] == 0 {                                 // is barrier1 finished(=not resetted)?
    barrier(barrier2, barrier1)
  } else if barrier2[threadIndex] == 0 {                                 // is barrier2 finished(=not resetted)?
    barrier(barrier3, barrier2)
  }


  func barrier(bar, delBar) {
    bar[threadIndex] := full & ~me;                                      // every thread but me has not yet arrived

    i := threadIndex+1 (mod threadCount)
    do {
      while bar[threadIndex]&(2^i) = 0 && i < numThreads { i := i + 1 }  // pick one thread that has not yet arrived

      if i < numThreads {
        bar[threadIndex] := bar[threadIndex] & bar[i]                    // pull his 'data' and connect it with ours by logical AND
      } else {
        i := 0
      }
    } while bar[threadIndex] != 0                                        // as long as not everyone arrived

    delBar[threadIndex] = full                                           // reset
  }


// 2^i is 2 to the power of i

// implementations/remember-others-and-add-fetch-rapl/main.c search for "super wasteful 5 barrier { "

