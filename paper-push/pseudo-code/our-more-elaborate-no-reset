variables:

  shared: bar[numThreads] (each process owns its own array element)
  local: me := $2^{threadIndex}$, full := $\sum_{i=0}^{numThreads-1}2^i$
  init: bar[*] := full

code per thread/process:

  bar[threadIndex] := full & ~me;                                      // every thread but me has not yet arrived

  i := threadIndex+1 (mod threadCount)
  do {
    while bar[threadIndex]&(2^i) = 0 && i < numThreads { i := i + 1 }  // pick one thread that has not yet arrived

    if i < numThreads {
      bar[threadIndex] := bar[threadIndex] & bar[i]                    // pull his 'data' and connect it with ours by logical AND
    } else {
      i := 0
    }
  } while bar[threadIndex] != 0                                        // as long as not everyone arrived


// 2^i is 2 to the power of i

// implementations/remember-others-and-add-fetch-rapl/main.c search for "super wasteful 5 barrier { "
