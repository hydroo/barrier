variables:

  shared:
    barrier[threadCount][threadCount] (each thread/process has its element locally)
    repetition[threadCount]           (keeps track of repetitions to avoid resets)
  init:
    barrier[*][*] := 0
    repetition[*] := 0

code per thread/process:

  repetition[threadIndex] += 1;                               // expect new repetition
  local rep = repetiton[threadIndex];

  for distance := 0; distance < numThreads; distance *= 2 {
    to   := (threadIndex + distance) % threadCount
    from := (threadIndex - distance) % threadCount

    barrier[to][threadIndex] := rep                           // set to-poor to repetiton counter

    while barrier[threadIndex][from] < rep {}                 // expect your from-poor to set your counter to the current repetition
  }

// implementations/remember-others-and-add-fetch-rapl/main.c search for "dissemination barrier { "
// adapted/taken from hoefler2005 Listing 2.7
